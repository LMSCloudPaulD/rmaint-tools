#!/usr/bin/env perl
use strict;
use warnings;
use Getopt::Long qw(:config no_ignore_case bundling);
use JSON::PP;
use File::Spec;
use File::Path   qw(make_path);
use Time::HiRes  qw(time);
use Scalar::Util qw(looks_like_number);
use IPC::Open3;
use Symbol qw(gensym);

my $DEFAULT_TEMPLATE =
    'Bug {{id}}: {{status_block}}{{importance_block}} {{summary}} | Assignee: {{assigned_to}} | QA: {{qa_contact}} | Depends: {{depends_on}} | Blocks: {{blocks}}';
my $JSON_UTF8           = JSON::PP->new->utf8;
my $JSON_UTF8_CANONICAL = JSON::PP->new->utf8->canonical;

my @common_bug_fields = qw(
    status
    resolution
    summary
    priority
    severity
    assigned_to
    qa_contact
    depends_on
    blocks
);

my %derived_fields = (
    bug_url           => 1,
    status_block      => 1,
    status_resolution => 1,
    resolution_suffix => 1,
    importance        => 1,
    importance_block  => 1,
    commit            => 1,
    commit_hash       => 1,
    commit_subject    => 1,
);

my $format_template;
my @extra_fields;
my $list_common_fields;
my $show_help;
my $no_common_fields;
my $batch_size    = $ENV{KOHA_BZ_BATCH_SIZE}    // 20;
my $base_url      = $ENV{KOHABUGZILLA_API_BASE} // 'https://bugs.koha-community.org/bugzilla3';
my $cache_dir     = $ENV{KOHA_BZ_CACHE_DIR};
my $cache_ttl     = defined $ENV{KOHA_BZ_CACHE_TTL} ? $ENV{KOHA_BZ_CACHE_TTL} : 300;
my $cache_enabled = 1;
my $request_delay = defined $ENV{KOHA_BZ_REQUEST_DELAY} ? $ENV{KOHA_BZ_REQUEST_DELAY} : 0.2;
my $max_commits =
    defined $ENV{KOHA_BZ_MAX_COMMITS} && $ENV{KOHA_BZ_MAX_COMMITS} ne ''
    ? $ENV{KOHA_BZ_MAX_COMMITS}
    : 400;
my $max_retries =
    defined $ENV{KOHA_BZ_MAX_RETRIES} && $ENV{KOHA_BZ_MAX_RETRIES} ne ''
    ? $ENV{KOHA_BZ_MAX_RETRIES}
    : 3;
my $assume_yes       = parse_bool( $ENV{KOHA_BZ_ASSUME_YES}, 0 );
my $progress_env_set = defined $ENV{KOHA_BZ_PROGRESS} ? 1 : 0;
my $show_progress    = parse_bool( $ENV{KOHA_BZ_PROGRESS}, 1 );
my $show_header      = parse_bool( $ENV{KOHA_BZ_HEADER},   1 );
my $separator        = defined $ENV{KOHA_BZ_SEPARATOR} ? $ENV{KOHA_BZ_SEPARATOR} : ' | ';

GetOptions(
    'format|f=s'         => \$format_template,
    'field|F=s@'         => \@extra_fields,
    'fields=s'           => sub { my @f = split /,/, $_[1]; push @extra_fields, @f; },
    'list-common-fields' => \$list_common_fields,
    'no-common-fields'   => \$no_common_fields,
    'batch-size=i'       => \$batch_size,
    'base-url=s'         => \$base_url,
    'cache-dir=s'        => \$cache_dir,
    'cache-ttl=i'        => \$cache_ttl,
    'no-cache'           => sub { $cache_enabled = 0; },
    'request-delay=f'    => \$request_delay,
    'no-throttle'        => sub { $request_delay = 0; },
    'max-commits=i'      => \$max_commits,
    'max-retries=i'      => \$max_retries,
    'y|yes|assume-yes'   => \$assume_yes,
    'progress!'          => \$show_progress,
    'header!'            => \$show_header,
    'separator=s'        => sub {
        my ( $opt_name, $opt_value ) = @_;
        $separator = $opt_value;
    },
    'help|h' => \$show_help,
) or die usage();

if ($show_help) {
    print usage();
    exit 0;
}

if ($list_common_fields) {
    print join( "\n", @common_bug_fields ), "\n";
    exit 0;
}

$assume_yes    = $assume_yes    ? 1 : 0;
$show_progress = $show_progress ? 1 : 0;
if ( !$progress_env_set && !-t STDERR ) {
    $show_progress = 0;
}
$show_header = $show_header ? 1 : 0;

if ( defined $max_commits && $max_commits ne '' ) {
    die "Error: max-commits must be numeric\n" unless looks_like_number($max_commits);
    $max_commits = int($max_commits);
    if ( $max_commits < 0 ) {
        die "Error: max-commits cannot be negative\n";
    }
}

if ( defined $max_retries && $max_retries ne '' ) {
    die "Error: max-retries must be numeric\n" unless looks_like_number($max_retries);
    $max_retries = int($max_retries);
    if ( $max_retries < 0 ) {
        die "Error: max-retries cannot be negative\n";
    }
}

$separator = defined $separator ? $separator : ' | ';
if ( $separator eq '\\t' ) {
    $separator = "\t";
}
elsif ( $separator eq '\\n' ) {
    $separator = "\n";
}
elsif ( $separator eq '\\r' ) {
    $separator = "\r";
}

my $structured_output = ( $separator ne ' | ' );

if ( !defined $cache_dir || $cache_dir eq '' ) {
    my $home = $ENV{HOME} || '.';
    $cache_dir = File::Spec->catdir( $home, '.cache', 'git-bz-overlay' );
}

if ( $cache_ttl <= 0 ) {
    $cache_enabled = 0;
}

if ( $batch_size !~ /^[1-9][0-9]*$/ ) {
    die "Error: batch-size must be a positive integer\n";
}

if ( !defined $request_delay || !looks_like_number($request_delay) || $request_delay < 0 ) {
    die "Error: request-delay must be a non-negative number\n";
}

$format_template //= $DEFAULT_TEMPLATE;

my @template_fields = collect_fields_from_template($format_template);

my @requested_fields;
my %seen_fields;

sub add_field {
    my ($field) = @_;
    return if !defined $field || $field eq '';
    return if $derived_fields{$field};
    return if $seen_fields{$field};
    push @requested_fields, $field;
    $seen_fields{$field} = 1;
}

add_field('id');

if ( !$no_common_fields ) {
    add_field($_) for @common_bug_fields;
}

add_field($_) for map {s/^\s+|\s+$//gr} @extra_fields;
add_field($_) for @template_fields;

if ( !@requested_fields ) {
    die "Error: No Bugzilla fields selected. Use --field or --fields to specify at least one.\n";
}

my @revision_args;
my @git_extra_args;
if (@ARGV) {
    my $separator_index = -1;
    for my $i ( 0 .. $#ARGV ) {
        if ( $ARGV[$i] eq '--' ) {
            $separator_index = $i;
            last;
        }
    }
    if ( $separator_index >= 0 ) {
        @revision_args  = @ARGV[ 0 .. $separator_index - 1 ]      if $separator_index > 0;
        @git_extra_args = @ARGV[ $separator_index + 1 .. $#ARGV ] if $separator_index < $#ARGV;
    }
    else {
        @revision_args = @ARGV;
    }
}

ensure_commands(qw(git));
my @http_required = qw();
if ( !$cache_enabled ) {

    # no-op
}

my @git_args = ( 'log', '--oneline' );
push @git_args, @git_extra_args if @git_extra_args;
push @git_args, @revision_args  if @revision_args;

my @commit_lines = run_git_log(@git_args);
if ( !@commit_lines ) {
    exit 0;
}

my ( $ordered_ids_ref, $ids_by_commit_ref ) = extract_bug_ids(@commit_lines);
my @ordered_ids   = @$ordered_ids_ref;
my %commit_to_ids = %$ids_by_commit_ref;

my $commit_count = scalar @commit_lines;
my $bug_count    = scalar @ordered_ids;

if ( defined $max_commits && $max_commits > 0 && $commit_count > $max_commits ) {
    if ($assume_yes) {
        warn sprintf "Notice: processing %d commits (limit %d) due to --yes/assume-yes option.\n", $commit_count, $max_commits;
    }
    else {
        my $prompt = sprintf( "About to process %d commits referencing up to %d bug(s). Continue? [y/N] ", $commit_count, $bug_count );
        unless ( prompt_for_confirmation($prompt) ) {
            warn "Aborted by user.\n";
            exit 1;
        }
    }
}

if ( !@ordered_ids ) {
    print join( "\n", @commit_lines ), "\n";
    exit 0;
}

my ( $cache_reader, $cache_writer ) = cache_helpers( $cache_dir, $cache_ttl, $cache_enabled, \@requested_fields );

my %bug_data;
my @needs_fetch;
my $total_bugs     = $bug_count;
my $processed_bugs = 0;
my $cache_hits     = 0;
my %fetch_attempts;
my %failed_ids;
for my $id (@ordered_ids) {
    my $cached = $cache_reader->($id);
    if ($cached) {
        $bug_data{$id} = $cached;
        $cache_hits++;
        $processed_bugs++;
    }
    else {
        push @needs_fetch, $id;
    }
}

if ( $total_bugs > 0 && $cache_hits > 0 ) {
    progress_report( $processed_bugs, $total_bugs, $cache_hits, 'cache hits' ) if $show_progress;
}

while (@needs_fetch) {
    my @batch   = splice @needs_fetch, 0, $batch_size;
    my $include = join( ',', @requested_fields );
    my $url     = sprintf( '%s/rest/bug?id=%s&include_fields=%s', $base_url, join( ',', @batch ), $include );
    my ( $ok, $body, $status_text ) = http_get($url);
    if ( !$ok ) {
        warn sprintf "Warning: Failed to fetch Bugzilla data for batch [%s]: %s\n", join( ',', @batch ), $status_text;
        handle_failed_ids( \@batch, $status_text, \%fetch_attempts, \%failed_ids, \@needs_fetch, $max_retries );
        if ( @needs_fetch && $request_delay > 0 ) {
            select undef, undef, undef, $request_delay;
        }
        next;
    }
    my $data = eval { $JSON_UTF8->decode($body) };
    if ( $@ || ref($data) ne 'HASH' ) {
        warn sprintf "Warning: Could not parse Bugzilla response for batch [%s]\n", join( ',', @batch );
        handle_failed_ids( \@batch, 'parse error', \%fetch_attempts, \%failed_ids, \@needs_fetch, $max_retries );
        if ( @needs_fetch && $request_delay > 0 ) {
            select undef, undef, undef, $request_delay;
        }
        next;
    }
    my $bugs        = $data->{bugs} || [];
    my $new_records = 0;
    my %returned_ids;
    for my $bug (@$bugs) {
        next if ref($bug) ne 'HASH';
        my %record;
        for my $field (@requested_fields) {
            my $value = exists $bug->{$field} ? stringify_value( $bug->{$field} ) : '';
            $record{$field} = $value;
        }
        if ( defined $record{id} ) {
            my $id         = $record{id};
            my $first_seen = !exists $bug_data{$id};
            $bug_data{$id}     = \%record;
            $returned_ids{$id} = 1;
            if ($first_seen) {
                $new_records++;
            }
            $cache_writer->( $id, \%record );
        }
    }

    if ( $new_records > 0 ) {
        $processed_bugs += $new_records;
        progress_report( $processed_bugs, $total_bugs, $cache_hits, sprintf( 'fetched %d', $new_records ) ) if $show_progress;
    }

    my @missing = grep { !$returned_ids{$_} } @batch;
    if (@missing) {
        handle_failed_ids( \@missing, 'missing from response', \%fetch_attempts, \%failed_ids, \@needs_fetch, $max_retries );
    }

    if ( @needs_fetch && $request_delay > 0 ) {
        select undef, undef, undef, $request_delay;
    }
}

if ( $show_progress && $total_bugs > 0 ) {
    my $final_note = 'complete';
    if (%failed_ids) {
        my $failed_count = scalar keys %failed_ids;
        $final_note .= sprintf( ' with %d failure%s', $failed_count, $failed_count == 1 ? '' : 's' );
    }
    progress_report( $processed_bugs, $total_bugs, $cache_hits, $final_note );
}

for my $id (@ordered_ids) {
    if ( !exists $bug_data{$id} ) {
        my $reason = $failed_ids{$id} || 'Bugzilla returned no data';
        warn sprintf "Warning: No Bugzilla data returned for bug %s (%s)\n", $id, $reason;
    }
}

my @header_fields = (
    'commit_hash', 'commit_subject', 'bug_id',  'status',  'importance',   'assignee',          'qa_contact', 'depends_on',
    'blocks',      'resolution',     'summary', 'bug_url', 'status_block', 'status_resolution', 'overlay'
);
my @structured_rows;
my @plain_rows;

for my $commit (@commit_lines) {
    my ( $hash, $subject ) = parse_commit_line($commit);
    my @ids = @{ $commit_to_ids{$commit} || [] };

    if ( !@ids ) {
        if ($structured_output) {
            push @structured_rows, [ $hash, $subject, ('') x ( scalar(@header_fields) - 2 ) ];
        }
        else {
            push @plain_rows, $commit;
        }
        next;
    }

    my @overlays;
    for my $id (@ids) {
        my $record = $bug_data{$id} || { id => $id };
        my %values = (
            %$record,
            bug_url           => sprintf( '%s/show_bug.cgi?id=%s', $base_url, $id ),
            resolution_suffix => resolution_suffix( $record->{resolution} ),
            status_resolution => status_resolution( $record->{status}, $record->{resolution} ),
            status_block      => status_block( $record->{status}, $record->{resolution} ),
            commit            => $commit,
            commit_hash       => $hash,
            commit_subject    => $subject,
        );
        my @importance_parts = grep { defined $_ && $_ ne '' } ( $values{priority}, $values{severity} );
        my $importance       = join( '/', @importance_parts );
        $values{importance}       = $importance;
        $values{importance_block} = @importance_parts ? " ($importance)" : '';
        for my $list_field (qw(depends_on blocks qa_contact)) {
            if ( ref $values{$list_field} eq 'ARRAY' ) {
                $values{$list_field} = join( ',', @{ $values{$list_field} } );
            }
        }
        $values{summary} = '(summary unavailable)'
            if !defined $values{summary} || $values{summary} eq '';

        my $rendered = render_template( $format_template, \%values );
        push @overlays, $rendered;

        if ($structured_output) {
            push @structured_rows,
                [
                $hash,
                $subject,
                $values{id}                // '',
                $values{status}            // '',
                $values{importance}        // '',
                $values{assigned_to}       // '',
                $values{qa_contact}        // '',
                $values{depends_on}        // '',
                $values{blocks}            // '',
                $values{resolution}        // '',
                $values{summary}           // '',
                $values{bug_url}           // '',
                $values{status_block}      // '',
                $values{status_resolution} // '',
                $rendered,
                ];
        }
    }

    next if $structured_output;

    my $joined_overlays = join( '; ', @overlays );
    push @plain_rows, $commit . '  |  ' . $joined_overlays;
}

if ($structured_output) {
    if ( $show_header && @structured_rows ) {
        print join( $separator, map { escape_separator( $_, $separator ) } @header_fields ), "\n";
    }
    for my $row (@structured_rows) {
        print join( $separator, map { escape_separator( $_ // '', $separator ) } @$row ), "\n";
    }
    exit 0;
}

for my $line (@plain_rows) {
    print $line, "\n";
}

exit 0;

sub usage {
    return <<'USAGE';
Usage: git-bz-overlay [options] [revisions...] [-- <extra git log args>...]

Overlay Bugzilla metadata on commits selected by a Git revision range or
any other git-log revision arguments. Without explicit revisions the
command runs `git log --oneline` for the current branch and extracts bug
numbers from commit subjects.

Options:
  -f, --format TEMPLATE      Custom output template (use {{field}} tokens)
  -F, --field FIELD          Request additional Bugzilla field (repeatable)
      --fields LIST          Comma-separated list of additional fields
      --no-common-fields     Do not include the built-in common field set
      --list-common-fields   Print common Bugzilla fields and exit
      --batch-size N         Override Bugzilla request batch size (default env KOHA_BZ_BATCH_SIZE or 20)
      --base-url URL         Bugzilla base URL (default env KOHABUGZILLA_API_BASE)
      --cache-dir PATH       Directory for cached bug responses (default ~/.cache/git-bz-overlay)
      --cache-ttl SEC        Cache TTL in seconds (default env KOHA_BZ_CACHE_TTL or 300; <=0 disables cache)
      --no-cache             Disable caching entirely
      --max-commits N        Prompt when commit count exceeds N (default env KOHA_BZ_MAX_COMMITS or 400; 0 disables)
      --max-retries N        Retry failed Bugzilla fetches up to N times (default env KOHA_BZ_MAX_RETRIES or 3; 0 = unlimited)
  -y, --yes, --assume-yes    Continue automatically when limits are exceeded
      --progress/--no-progress
                             Toggle progress reporting (default env KOHA_BZ_PROGRESS or on)
      --header/--no-header    Toggle header row for structured output (default env KOHA_BZ_HEADER or on)
      --separator SEP        Emit structured rows separated by SEP (default env KOHA_BZ_SEPARATOR or ' | ')
      --request-delay SEC    Delay between Bugzilla batches (default env KOHA_BZ_REQUEST_DELAY or 0.2)
      --no-throttle          Disable the inter-request delay (same as --request-delay 0)
  -h, --help                 Show this help text

Derived template placeholders:
  {{bug_url}} {{status_block}} {{status_resolution}} {{resolution_suffix}}
  {{commit}} {{commit_hash}} {{commit_subject}}

Examples:
  git-bz-overlay 25.05.x...upstream/main
  git-bz-overlay HEAD~20..HEAD
  git-bz-overlay --format '{{id}}\t{{status}}\t{{commit_hash}}' main
  git-bz-overlay -- --since=2024-01-01 --author='Jane Doe'
  git-bz-overlay feature-branch -- --no-merges
USAGE
}

sub ensure_commands {
    my @commands = @_;
    for my $cmd (@commands) {
        my $path = `command -v $cmd 2>/dev/null`;
        if ( !$path ) {
            die "Error: required command '$cmd' not found in PATH\n";
        }
    }
}

sub run_git_log {
    my @args = @_;
    open my $fh, '-|', 'git', @args or die "Error: failed to run git log\n";
    my @lines;
    while ( my $line = <$fh> ) {
        chomp $line;
        push @lines, $line if length $line;
    }
    close $fh;
    return @lines;
}

sub extract_bug_ids {
    my @commits = @_;
    my %seen;
    my @ordered;
    my %per_commit;
    for my $commit (@commits) {
        my %seen_in_commit;
        while ( $commit =~ /[Bb]ug[\s_#-]*(\d+)/g ) {
            my $id = $1;
            next if $seen_in_commit{$id};
            push @{ $per_commit{$commit} }, $id;
            $seen_in_commit{$id} = 1;
            if ( !$seen{$id} ) {
                push @ordered, $id;
                $seen{$id} = 1;
            }
        }
    }
    return ( \@ordered, \%per_commit );
}

sub collect_fields_from_template {
    my ($template) = @_;
    my %seen;
    my @fields;
    while ( $template =~ /\{\{([A-Za-z0-9_]+)\}\}/g ) {
        my $field = $1;
        next if $derived_fields{$field};
        next if $seen{$field};
        push @fields, $field;
        $seen{$field} = 1;
    }
    return @fields;
}

sub parse_bool {
    my ( $value, $default ) = @_;
    return $default unless defined $value;
    return 1 if $value =~ /^(?:1|true|yes|on)$/i;
    return 0 if $value =~ /^(?:0|false|no|off)$/i;
    return $default;
}

sub prompt_for_confirmation {
    my ($message) = @_;
    if ( open my $tty, '<', '/dev/tty' ) {
        print STDERR $message;
        my $response = <$tty>;
        close $tty;
        return defined $response && $response =~ /^[yY]/;
    }

    if ( -t STDIN ) {
        print STDERR $message;
        my $response = <STDIN>;
        return defined $response && $response =~ /^[yY]/;
    }

    warn "Unable to prompt for confirmation (no TTY/interactive input).\n";
    return 0;
}

sub http_get {
    my ($url) = @_;
    my $curl_cmd = [ 'curl', '-sS', '--fail-with-body', '--max-time', '20', '--header', 'Accept: application/json', '--user-agent', 'git-bz-overlay/1.0', $url, ];

    if ( my $curl = `command -v curl 2>/dev/null` ) {
        chomp $curl;
        $curl_cmd->[0] = $curl;
    }
    else {
        die "Error: curl is required for Bugzilla requests but was not found in PATH\n";
    }

    my $stderr = gensym;
    my $pid    = open3( my $stdin, my $stdout, $stderr, @$curl_cmd );
    close $stdin;
    my $body = do { local $/; <$stdout> // '' };
    my $err  = do { local $/; <$stderr> // '' };
    close $stdout;
    close $stderr;
    waitpid $pid, 0;
    my $exit = $? >> 8;

    if ( $exit == 0 ) {
        return ( 1, $body, 'OK' );
    }

    my $status_text = 'curl error';
    if ( $err =~ /HTTP\/(?:\d+\.\d+)\s+(\d+)\s+(.*)/ ) {
        $status_text = sprintf( 'HTTP %s %s', $1, $2 );
    }
    elsif ( length $err ) {
        $status_text = $err;
    }

    return ( 0, undef, $status_text );
}

sub handle_failed_ids {
    my ( $ids_ref, $reason, $attempts_ref, $failed_ref, $queue_ref, $max_retries ) = @_;
    return unless $ids_ref && @$ids_ref;
    for my $id (@$ids_ref) {
        my $attempts = ++$attempts_ref->{$id};
        if ( $max_retries == 0 || $attempts <= $max_retries ) {
            push @$queue_ref, $id;
        }
        else {
            $failed_ref->{$id} = sprintf( '%s after %d attempt%s', $reason, $attempts, $attempts == 1 ? '' : 's' );
        }
    }
}

sub progress_report {
    my ( $processed, $total, $cache_hits, $note ) = @_;
    my $percent = $total ? sprintf( '%.1f%%', ( $processed / $total ) * 100 ) : '100%';
    my $message = sprintf( '[git-bz-overlay] bugs ready: %d/%d (%s)', $processed, $total, $percent );
    if ( defined $cache_hits && $cache_hits > 0 ) {
        $message .= sprintf( ' (cache %d)', $cache_hits );
    }
    if ( defined $note && length $note ) {
        $message .= " - $note";
    }
    print STDERR $message, "\n";
}

sub escape_separator {
    my ( $value, $sep ) = @_;
    return '' unless defined $value;
    if ( $sep eq "\t" ) {
        $value =~ s/\t/\\t/g;
        $value =~ s/\n/\\n/g;
    }
    elsif ( $sep eq ',' ) {
        if ( $value =~ /[",\n]/ ) {
            $value =~ s/"/""/g;
            $value = '"' . $value . '"';
        }
    }
    elsif ( $sep eq '|' ) {
        $value =~ s/\|/\\|/g;
    }
    else {
        my $escaped_sep = quotemeta($sep);
        $value =~ s/$escaped_sep/\\$sep/g;
    }
    return $value;
}

sub stringify_value {
    my ($value) = @_;
    return '' if !defined $value;
    if ( ref $value eq 'ARRAY' ) {
        return join( ', ', map { stringify_value($_) } @$value );
    }
    if ( ref $value eq 'HASH' ) {
        return $JSON_UTF8_CANONICAL->encode($value);
    }
    return $value;
}

sub cache_helpers {
    my ( $dir, $ttl, $enabled, $fields_ref ) = @_;
    if ( !$enabled ) {
        return ( sub {undef}, sub { } );
    }
    eval { make_path($dir) unless -d $dir; };
    if ($@) {
        warn "Warning: Unable to create cache directory '$dir'. Disabling cache.\n";
        return ( sub {undef}, sub { } );
    }
    my $reader = sub {
        my ($id) = @_;
        my $path = File::Spec->catfile( $dir, "$id.json" );
        return undef if !-f $path;
        if ( $ttl > 0 ) {
            my $mtime = ( stat($path) )[9];
            if ( !$mtime || ( time() - $mtime ) > $ttl ) {
                return undef;
            }
        }
        open my $fh, '<', $path or return undef;
        local $/;
        my $content = <$fh>;
        close $fh;
        my $data = eval { $JSON_UTF8->decode($content) };
        return undef if $@ || ref($data) ne 'HASH';
        for my $field (@$fields_ref) {
            return undef if !exists $data->{$field};
        }
        return $data;
    };
    my $writer = sub {
        my ( $id, $data_ref ) = @_;
        my $path = File::Spec->catfile( $dir, "$id.json" );
        open my $fh, '>', $path or return;
        print {$fh} $JSON_UTF8_CANONICAL->encode($data_ref);
        close $fh;
    };
    return ( $reader, $writer );
}

sub resolution_suffix {
    my ($resolution) = @_;
    return '' if !defined $resolution || $resolution eq '' || $resolution eq 'N/A';
    return '/' . $resolution;
}

sub status_resolution {
    my ( $status, $resolution ) = @_;
    $status = defined $status && $status ne '' ? $status : 'UNKNOWN';
    return $status . resolution_suffix($resolution);
}

sub status_block {
    my ( $status, $resolution ) = @_;
    return '[' . status_resolution( $status, $resolution ) . ']';
}

sub render_template {
    my ( $template, $values_ref ) = @_;
    my %values = %$values_ref;
    $template =~ s/\{\{([A-Za-z0-9_]+)\}\}/defined $values{$1} ? $values{$1} : ''/ge;
    return $template;
}

sub parse_commit_line {
    my ($line) = @_;
    if ( $line =~ /^(\S+)\s+(.*)$/ ) {
        return ( $1, $2 );
    }
    return ( $line, $line );
}
